#pragma checksum "C:\Users\hopki\OneDrive\Documents\Myaddon\Wickedaddon\WowClassicGrindBot\PathingAPI\Pages\Watch.razor" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "14affe960d3de347d91e1b0c550742d7867f948c"
// <auto-generated/>
#pragma warning disable 1591
namespace PathingAPI.Pages
{
    #line hidden
    using System;
    using System.Linq;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Components;
#nullable restore
#line 1 "C:\Users\hopki\OneDrive\Documents\Myaddon\Wickedaddon\WowClassicGrindBot\PathingAPI\_Imports.razor"
using System.Net.Http;

#line default
#line hidden
#nullable disable
#nullable restore
#line 2 "C:\Users\hopki\OneDrive\Documents\Myaddon\Wickedaddon\WowClassicGrindBot\PathingAPI\_Imports.razor"
using Microsoft.AspNetCore.Authorization;

#line default
#line hidden
#nullable disable
#nullable restore
#line 3 "C:\Users\hopki\OneDrive\Documents\Myaddon\Wickedaddon\WowClassicGrindBot\PathingAPI\_Imports.razor"
using Microsoft.AspNetCore.Components.Authorization;

#line default
#line hidden
#nullable disable
#nullable restore
#line 4 "C:\Users\hopki\OneDrive\Documents\Myaddon\Wickedaddon\WowClassicGrindBot\PathingAPI\_Imports.razor"
using Microsoft.AspNetCore.Components.Forms;

#line default
#line hidden
#nullable disable
#nullable restore
#line 5 "C:\Users\hopki\OneDrive\Documents\Myaddon\Wickedaddon\WowClassicGrindBot\PathingAPI\_Imports.razor"
using Microsoft.AspNetCore.Components.Routing;

#line default
#line hidden
#nullable disable
#nullable restore
#line 6 "C:\Users\hopki\OneDrive\Documents\Myaddon\Wickedaddon\WowClassicGrindBot\PathingAPI\_Imports.razor"
using Microsoft.AspNetCore.Components.Web;

#line default
#line hidden
#nullable disable
#nullable restore
#line 7 "C:\Users\hopki\OneDrive\Documents\Myaddon\Wickedaddon\WowClassicGrindBot\PathingAPI\_Imports.razor"
using Microsoft.JSInterop;

#line default
#line hidden
#nullable disable
#nullable restore
#line 8 "C:\Users\hopki\OneDrive\Documents\Myaddon\Wickedaddon\WowClassicGrindBot\PathingAPI\_Imports.razor"
using PathingAPI;

#line default
#line hidden
#nullable disable
#nullable restore
#line 9 "C:\Users\hopki\OneDrive\Documents\Myaddon\Wickedaddon\WowClassicGrindBot\PathingAPI\_Imports.razor"
using PathingAPI.Shared;

#line default
#line hidden
#nullable disable
#nullable restore
#line 3 "C:\Users\hopki\OneDrive\Documents\Myaddon\Wickedaddon\WowClassicGrindBot\PathingAPI\Pages\Watch.razor"
using System.Collections.Generic;

#line default
#line hidden
#nullable disable
#nullable restore
#line 4 "C:\Users\hopki\OneDrive\Documents\Myaddon\Wickedaddon\WowClassicGrindBot\PathingAPI\Pages\Watch.razor"
using PathingAPI.Data;

#line default
#line hidden
#nullable disable
#nullable restore
#line 5 "C:\Users\hopki\OneDrive\Documents\Myaddon\Wickedaddon\WowClassicGrindBot\PathingAPI\Pages\Watch.razor"
using PatherPath.Graph;

#line default
#line hidden
#nullable disable
    [Microsoft.AspNetCore.Components.RouteAttribute("/Watch")]
    public partial class Watch : Microsoft.AspNetCore.Components.ComponentBase
    {
        #pragma warning disable 1998
        protected override void BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder __builder)
        {
            __builder.AddMarkupContent(0, "<div id=\"canvasText\" style=\"position: relative; z-index: 2; left: 0px;padding-left:10px; top: 20px; height:30px; background-color: black;color:white\">\r\n    ...\r\n</div>\r\n");
            __builder.AddMarkupContent(1, "<canvas id=\"renderCanvas\" style=\"background:black\">\r\n</canvas>");
        }
        #pragma warning restore 1998
#nullable restore
#line 15 "C:\Users\hopki\OneDrive\Documents\Myaddon\Wickedaddon\WowClassicGrindBot\PathingAPI\Pages\Watch.razor"
       

    private bool initialised = false;
    System.Threading.Thread RefreshSearchThread;

    [Parameter]
    public int PathColour { get; set; } = 1;

    [Parameter]
    public string Name { get; set; } = "path";

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            pPatherService.OnLog = Log;
            await jsRuntime.InvokeVoidAsync("createScene");
            Initialise();
        }
    }

    private void Initialise()
    {
        if (!pPatherService.HasInitialised)
        {
            InvokeAsyncBase(() => jsRuntime.InvokeVoidAsync("log", "Waiting for first search from the API...")).Wait();
        }
        else
        {
            initialised = true;
            var chunks = pPatherService.SetNotifyChunkAdded(TriangleWorld_NotifyChunkAdded);
            this.AddChunks(chunks);

            pPatherService.SetOnPathCreated(DrawFinalPath);
            RefreshSearchThread = new System.Threading.Thread(new System.Threading.ThreadStart(SearchPathRefresh));
            RefreshSearchThread.Start();
            pPatherService.OnReset = () => { InvokeAsyncBase(() => jsRuntime.InvokeVoidAsync("clear")).Wait(); ; };

            pPatherService.OnLinesAdded = Drawlines;
            pPatherService.OnSphereAdded = DrawSphere;
        }
    }

    public async Task InvokeAsyncBase(Action action)
    {
        await base.InvokeAsync(() =>
        {
            try { action(); } catch { }
        });
    }

    public void Log(string message)
    {
        try
        {
            System.Diagnostics.Debug.WriteLine(">" + message);
            InvokeAsyncBase(() => jsRuntime.InvokeVoidAsync("log", message)).Wait();
            if (!initialised) { Initialise(); }
        }
        catch (Exception ex)
        {
            Log(ex.Message);
        }
    }

    public void DrawFinalPath(PatherPath.Graph.Path spotPath)
    {
        if (spotPath != null)
        {
            var path = spotPath.locations.Select(s => Vertex.Create(s.X, s.Y, s.Z)).ToList();
            InvokeAsyncBase(() => jsRuntime.InvokeVoidAsync("removeMeshes", Name)).Wait(); ;
            InvokeAsyncBase(() => jsRuntime.InvokeVoidAsync("drawPath", path, PathColour, Name)).Wait(); ;

            System.Threading.Thread.Sleep(1000);
            InvokeAsyncBase(() => jsRuntime.InvokeVoidAsync("removeMeshes", "search")).Wait(); ;
            InvokeAsyncBase(() => jsRuntime.InvokeVoidAsync("removeMeshes", "closest")).Wait(); ;
            InvokeAsyncBase(() => jsRuntime.InvokeVoidAsync("removeMeshes", "end")).Wait(); ;
        }
        else
        {
            Log("No path found");
        }
    }

    private Location lastFrom = new Location(0, 0,0);
    private Location lastTo = new Location(0, 0, 0);
    private Location lastClosest = new Location(0, 0, 0);
    private Location lastPeek = new Location(0, 0, 0);

    public void SearchPathRefresh()
    {
        while (true)
        {
            if (PatherPath.Graph.PathGraph.SearchEnabled)
            {
                try
                {
                    var spots = pPatherService.GetCurrentSearchPath();
                    if (spots != null)
                    {
                        var path = spots.Where(s => s != null).Select(s => Vertex.Create(s.X, s.Y, s.Z));
                        if (path.Count() > 0)
                        {
                            InvokeAsyncBase(() => jsRuntime.InvokeVoidAsync("drawPath", path, 4, "search")).Wait(); ;
                        }
                    }

                    var from = pPatherService.SearchFrom;
                    var to = pPatherService.SearchTo;

                    if (from != null && to != null && lastFrom.X != from.X || lastTo.X != lastTo.X)
                    {
                        jsRuntime.InvokeVoidAsync("drawLine", Vertex.Create(from.X, from.Y, from.Z), 2, "start2").ConfigureAwait(false);
                        jsRuntime.InvokeVoidAsync("drawLine", Vertex.Create(to.X, to.Y, to.Z), 3, "end").ConfigureAwait(false);
                        lastFrom = from;
                        lastTo = to;
                    }

                    if (pPatherService.ClosestLocation != null)
                    {
                        if (lastClosest.X != pPatherService.ClosestLocation.X)
                        {
                            jsRuntime.InvokeVoidAsync("drawLine", Vertex.Create(pPatherService.ClosestLocation.X, pPatherService.ClosestLocation.Y, pPatherService.ClosestLocation.Z), 5, "closest").ConfigureAwait(false);
                            lastClosest = pPatherService.ClosestLocation;
                        }
                    }

                    if (pPatherService.PeekLocation != null)
                    {
                        if (lastPeek.X != pPatherService.PeekLocation.X)
                        {
                            jsRuntime.InvokeVoidAsync("drawLine", Vertex.Create(pPatherService.PeekLocation.X, pPatherService.PeekLocation.Y, pPatherService.PeekLocation.Z), 6, "peek").ConfigureAwait(false);
                            lastPeek = pPatherService.PeekLocation;
                        }
                    }

                }
                catch (Exception ex)
                {
                    Log(ex.Message);
                }
            }
            System.Threading.Thread.Sleep(50);
        }
    }

    private void DrawSphere(SphereEventArgs e)
    {
        InvokeAsyncBase(() => jsRuntime.InvokeVoidAsync("drawSphere", e.Vertex, e.Colour, e.Name)).Wait(); ;
    }


    private void Drawlines(LinesEventArgs e)
    {
        InvokeAsyncBase(() => jsRuntime.InvokeVoidAsync("drawPath", e.Lines, e.Colour, e.Name)).Wait(); ;
    }

    private void TriangleWorld_NotifyChunkAdded(WowTriangles.ChunkAddedEventArgs e)
    {
        var triangles = new List<WowTriangles.TriangleCollection> { e.Triangles };
        AddChunks(triangles);
    }

    private void AddChunks(List<WowTriangles.TriangleCollection> chunks)
    {
        lock (this)
        {
            var positions = MeshFactory.CreatePointList(chunks);
            var water = MeshFactory.CreateTrianglesList(1, chunks);
            FixMaxWaterHeight(water, positions);
            var models = new List<int[]>();
            models.Add(MeshFactory.CreateTrianglesList(0, chunks));
            models.Add(water);
            models.Add(MeshFactory.CreateTrianglesList(2, chunks));
            models.Add(MeshFactory.CreateTrianglesList(4, chunks));

            InvokeAsyncBase(() => jsRuntime.InvokeVoidAsync("addModels", models, positions)).Wait();
        }
    }

    private void FixMaxWaterHeight(int[] waterPoints, PathingAPI.Data.Vertex[] positions)
    {
        var zlist = waterPoints.Select(pt => positions[pt].z).ToList();
        if (zlist.Count > 1)
        {
            var meanz = zlist[zlist.Count / 2];
            var minz = zlist.Min();
            waterPoints.ToList().ForEach(pt =>
            {
                if (positions[pt].z > minz) { positions[pt].z = minz; }
            });
        }
    }

#line default
#line hidden
#nullable disable
        [global::Microsoft.AspNetCore.Components.InjectAttribute] private PPatherService pPatherService { get; set; }
        [global::Microsoft.AspNetCore.Components.InjectAttribute] private IJSRuntime jsRuntime { get; set; }
    }
}
#pragma warning restore 1591
